[
    {
        "role": "system",
        "content": "Du bist ein freundlicher Assistent und ein Programmierspezialist, der in deutscher Sprache antwortet"
    },
    {
        "role": "user",
        "content": "# Rolle der KI\nDu bist ein Code-Generator und Assistent für die Visual Studio Code Extension \"Business Central AL Test Runner\". \nDu bist Experte in TypeScript und kennst dich auch mit dem Dynamics Business Central AL Testtool aus.\n\nVon dir wird erwartet:\n- Du gibst finalen Produktivcode aus, der direkt in die Lösung integriert werden kann.\n- Du machst Verbesserungsvorschläge bezüglich Code und Architektur, wenn du Potenzial hierfür siehst.\n- Du hältst die Gesprächshistorie kurz, um das Kontextfenster klein zu halten bzw. die Anzahl der Token so wenig wie möglich zu belasten.\n- Du wiederholst nicht ständig den kompletten Code, sondern gibst nur die Änderungen bzw. Neuerungen wieder. (Ausnahme: Ich bitte dich explizit darum.)\n\nKernfunktionalität der Visual Studio Code Extension:\n1. Der Business Central Entwickler soll automatisierte Tests direkt aus Visual Studio Code heraus ausführen können, ohne auf das AL Test Tool im Browser wechseln zu müssen.\n2. Die Extension erkennt anhand der von Git registrierten Änderungen, welche Tests ausgeführt werden sollen, und führt diese selektiv aus, um Zeit zu sparen. \n   _Auf Business Central Seite werden hierzu in einem Vorlauf die bei einem Test involvierten Objekte via Code-Coverage aufgezeichnet und in einer Object-Test Mapping Tabelle gespeichert._\n3. Sie kann Business Central AL Projekte kompilieren und veröffentlichen.\n4. Sie fügt die Anzahl der ausgeführten, negativen und positiven Tests in die Commit-Nachricht ein.\n\n### Grobkonzept\n\n#### Einführung\nIch bin Mitglied eines erfahrenen Dynamics Business Central AL Entwicklerteams von ca. 6 Entwicklern. \nWir entwickeln gemeinsam für zwei BC Branchenlösungen (Healthcare und Medtec). \nHierfür sind sehr viele automatisierte Tests implementiert worden. \nDas hat leider die negative Folge, dass die Tests eine sehr lange Laufzeit haben. \nDa wir die Testabdeckung erhöhen wollen, ist die Tendenz steigend. \nMeine Team-Mitglieder und ich wünschen uns daher einen Weg, wie wir eine Programmierung möglichst effizient und zielgerichtet, \"mal eben\" testen können, bevor wir einen Pull-Request absetzen.  \nDas ist der Grund für das Projekt.\n\n#### Komponenten\nDie Lösung besteht aus zwei Hauptkomponenten:\n1. **Business Central App \"Business Central AL Test Runner\"**\n2. **Visual Studio Code Extension \"Business Central AL Test Runner\"**\n\n#### Business Central App\nDie Business Central App bietet einen WebService, der folgende Aktionen ausführt:\n\n- **TestSuite Management:**\n  - Anlegen, Hinzufügen von Test-Codeunits und Löschen von TestSuites.\n\n- **Test Execution:**\n  - Ausführen von Tests und Export/Download der Testergebnisse und Fehlermeldungen.\n\n- **Mapping & Exclusion Management:**\n  - Erstellung und Export/Import eines Objekt-/Testfall-Mappings zur Ermittlung auszuführender Tests.\n  - Import von Ausschlussdateien zur Deaktivierung und bewussten Überspringung von Testfällen.\n\n#### Visual Studio Code Extension\nDie Visual Studio Code Extension bietet benutzerfreundliche Kommandos und Ansichten, die die Funktionen der Business Central App nutzen. Die Hauptfunktionen sind:\n\n- **Projekt- und Test-Erkennung:**\n  - Automatische Erkennung, welche Projekte die reguläre App (Main-App) und die Test-App enthalten.\n    - Anmerkung: Die Tests zu einer App sind in einer separaten TestApp ausgelagert. Beide Projekte liegen im selben Git-Repository, wobei nur die Test-App Microsoft Standard Test Libraries referenziert.\n\n- **Compiler- und Objekt-Erkennung:**\n  - Lokalisierung des AL-Kompilers (alc.exe) für die aktuell verwendete \"AL Language Extension for Microsoft Dynamics 365 Business Central\" Version.\n  - Erkennung, welche Business Central Objekte durch Git-Änderungen betroffen sind.\n\n- **Konfigurations- und Credentials-Management:**\n  - Auswahl einer Launch.json Konfiguration zur Festlegung des Ziels für Business Central Aktivitäten.\n    - Anhand der Konfiguration wird ein TestSuite-Vorschlag erstellt, der die Maximallänge von 10 Zeichen nicht überschreitet.\n  - Abfrage und Speicherung von Anmeldedaten (immer basierend auf NavUserPassword, Base-Authentication).\n\n- **Fehlertolerante Kompilierung und Veröffentlichung:**\n  - Funktion zur Kompilierung von Projekten, wobei nur Fehler relevant sind und Warnungen ignoriert werden.\n  - Veröffentlichung von Apps in der Zielumgebung gemäß der Launch.json Konfiguration.\n\n- **Ansichten und Benutzeroberfläche:**\n  - Erweiterung der \"Source Control\" View um eine \"Test\" Ansicht, die nur Tests im Zusammenhang mit den geänderten Objekten anzeigt.\n  - Eine zusätzliche \"Business Central AL Test Runner\" View, die alle Tests der TestSuite in einer Baumstruktur darstellt:\n    - Wurzelelement: TestSuite Name\n    - Zweite Ebene: Test-Codeunit\n    - Dritte Ebene: Einzelne Tests\n  - Testcases mit Ampeldarstellung (Status: nicht ausgeführt, in Ausführung, negativ getestet, positiv getestet).\n  - Negative Testcases haben ein Child-Element zur Anzeige der Fehlermeldung.\n  - Menü-Punkte für verschiedene Aktionen: \"Alle Apps kompilieren und veröffentlichen\", \"Main App kompilieren und veröffentlichen\", \"Test App kompilieren und veröffentlichen\", \"Alle Tests ausführen\", \"Ausgewählte Tests ausführen\".\n  - Hover-Funktion über Testcases zur Anzeige von Erfolgs- oder Fehlermeldungen.\n\n- **Commit-Integration:**\n  - Erweiterung der \"Git Commitmessage\" Ansicht der \"Source Control\" View um einen \"Test Changes\" Menüpunkt:\n    1. Ermittlung der auszuführenden Tests anhand der Git-Änderungen und des Objekt-Test-Mappings.\n    2. Kompilierung und Veröffentlichung der Main App.\n    3. Kompilierung und Veröffentlichung der Test-App.\n    4. Aktualisierung der Ausschlussdatei im Business Central Zielsystem.\n    5. Ausführung der ermittelten Tests.\n    6. Automatisiertes Anfügen der Testergebnisse an die Commit-Message.\n\n---\n\n### Zusammenfassung\nDie \"Business Central AL Test Runner\" Lösung besteht aus einer Business Central App und einer Visual Studio Code Extension, die nahtlos zusammenarbeiten, um Business Central Entwickler zu unterstützen:\n\n1. **Business Central App:**\n   - Bietet WebServices für TestSuite Management, Test Execution, Mapping und Exclusion Management.\n\n2. **Visual Studio Code Extension:**\n   - Automatisiert und vereinfacht die Testausführung direkt aus Visual Studio Code heraus.\n   - Integriert Kommandos und Ansichten zur effizienten Verwaltung von Tests und Projekten.\n   - Unterstützt fehlertolerante Kompilierung und Veröffentlichung.\n   - Erweitert die Source Control View für besseren Überblick und einfache Navigation.\n\nDurch die Nutzung dieser beiden Komponenten können Entwickler Zeit sparen und die Qualität ihrer Business Central Anwendungen durch automatisierte Tests verbessern. Die Lösung ist darauf ausgelegt, sowohl die Testausführung als auch die Verwaltung von Testfällen und Projekten effizienter und benutzerfreundlicher zu gestalten.\n\n---\n\n\nEs folgen nun einige wichtige Business Central AL und Visual Studio Code Extension Typescript Dateien, damit der Kontext vervollständigt ist."
    },
    {
        "role": "user",
        "content": "namespace KonnosPB.Al.TestRunner;\nusing System.TestTools.TestRunner;\nusing System.Tooling;\nusing System.TestTools.CodeCoverage;\nusing System.Reflection;\n\ncodeunit 63100 WebApi\n{\n    Subtype = Normal;\n    Permissions = tabledata \"AL Test Suite\" = RIMD, tabledata \"Test Method Line\" = RIMD;\n\n    [ServiceEnabled]\n    procedure Ping(): Boolean\n    begin\n        exit(true);\n    end;\n\n    [ServiceEnabled]\n    procedure GetTestSuites() JsonResult: Text\n    var\n        ALTestSuite: Record \"AL Test Suite\";\n        JsonArray: JsonArray;\n    begin\n        if ALTestSuite.FindSet(false) then\n            repeat\n                JsonArray.Add(ALTestSuite.Name);\n            until ALTestSuite.Next() = 0;\n        JsonArray.WriteTo(JsonResult);\n        exit(JsonResult);\n    end;\n\n    [ServiceEnabled]\n    procedure NewTestSuite(TestSuiteName: Text) JsonResult: Text\n    var\n        ALTestSuite: Record \"AL Test Suite\";\n        TestSuiteMgt: Codeunit \"Test Suite Mgt.\";\n        TestSuiteCode: Code[10];\n    begin\n        ALTestSuite.SetRange(Name, TestSuiteName);\n        if not ALTestSuite.IsEmpty() then\n            exit;\n        TestSuiteCode := CopyStr(TestSuiteName, 1, MaxStrLen(TestSuiteCode));\n        TestSuiteMgt.CreateTestSuite(TestSuiteCode);\n    end;\n\n    [ServiceEnabled]\n    procedure AddTests(TestSuiteName: Text; FromId: Integer; ToId: Integer)\n    var\n        ALTestSuite: Record \"AL Test Suite\";\n        TestSuiteMgt: Codeunit \"Test Suite Mgt.\";\n        CodeunitFilterTxt: Label '%1..%2', Locked = true;\n        Filter: Text;\n    begin\n        NewTestSuite(TestSuiteName);  // Skips if exist\n        ALTestSuite.Get(TestSuiteName);\n\n        Filter := StrSubstNo(CodeunitFilterTxt, FromId, ToId);\n        TestSuiteMgt.SelectTestMethodsByRange(ALTestSuite, Filter);\n    end;\n\n    [ServiceEnabled]\n    procedure AddTests(TestSuiteName: Text; CodeunitFilter: Text)\n    var\n        AllObjWithCaption: Record AllObjWithCaption;\n        ALTestSuite: Record \"AL Test Suite\";\n        TestSuiteMgt: Codeunit \"Test Suite Mgt.\";\n    begin\n        NewTestSuite(TestSuiteName);  // Skips if exist\n        ALTestSuite.Get(TestSuiteName);\n\n        AllObjWithCaption.Reset();\n        AllObjWithCaption.SetRange(\"Object Subtype\", 'test');\n        AllObjWithCaption.SetRange(\"Object Type\", AllObjWithCaption.\"Object Type\"::Codeunit);\n        AllObjWithCaption.SetFilter(\"Object Name\", CodeunitFilter);\n        TestSuiteMgt.GetTestMethods(ALTestSuite, AllObjWithCaption);\n    end;\n\n    [ServiceEnabled]\n    procedure GetTests(TestSuiteName: Text) JsonResult: Text\n    var\n        TestMethodLine: Record \"Test Method Line\";\n        InStream: InStream;\n        JsonArray: JsonArray;\n        JsonObject: JsonObject;\n        BlobVal: Text;\n    begin\n        TestMethodLine.Reset();\n        TestMethodLine.SetRange(\"Test Suite\", TestSuiteName);\n        if TestMethodLine.FindSet(false) then\n            repeat\n                Clear(JsonObject);\n                JsonObject.Add(TestMethodLine.FieldName(\"Line No.\"), TestMethodLine.\"Line No.\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Line Type\"), TestMethodLine.\"Line Type\");\n                JsonObject.Add(TestMethodLine.FieldName(Name), TestMethodLine.Name);\n                JsonObject.Add(TestMethodLine.FieldName(Result), TestMethodLine.Result);\n                JsonObject.Add(TestMethodLine.FieldName(Run), TestMethodLine.Run);\n                JsonObject.Add(TestMethodLine.FieldName(\"Test Codeunit\"), TestMethodLine.\"Test Codeunit\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Function\"), TestMethodLine.Function);\n                JsonObject.Add(TestMethodLine.FieldName(Level), TestMethodLine.Level);\n                JsonObject.Add(TestMethodLine.FieldName(\"Start Time\"), TestMethodLine.\"Start Time\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Finish Time\"), TestMethodLine.\"Finish Time\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Skip Logging Results\"), TestMethodLine.\"Skip Logging Results\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Error Code\"), TestMethodLine.\"Error Code\");\n                JsonObject.Add(TestMethodLine.FieldName(\"Error Message Preview\"), TestMethodLine.\"Error Message Preview\");\n\n                TestMethodLine.CalcFields(\"Error Call Stack\", \"Error Message\");\n                TestMethodLine.\"Error Message\".CreateInStream(InStream);\n                InStream.Read(BlobVal);\n                JsonObject.Add(TestMethodLine.FieldName(\"Error Message\"), BlobVal);\n\n                TestMethodLine.\"Error Call Stack\".CreateInStream(InStream);\n                InStream.Read(BlobVal);\n                JsonObject.Add(TestMethodLine.FieldName(\"Error Call Stack\"), BlobVal);\n                JsonArray.Add(JsonObject);\n            until TestMethodLine.Next() = 0;\n        JsonArray.WriteTo(JsonResult);\n        exit(JsonResult);\n    end;\n\n    [ServiceEnabled]\n    procedure ApplyTests(TestSuiteName: Text; JsonTests: Text; BuildMapping: Boolean) JsonResult: Text\n    var\n        ALTestSuite: Record \"AL Test Suite\";\n        CodeCoverage: Record \"Code Coverage\";\n        ObjectTestMapping: Record ObjectTestMapping;\n        TestMethodLine: Record \"Test Method Line\";\n        CodeCoverageMgt: Codeunit \"Code Coverage Mgt.\";\n        TestSuiteMgt: Codeunit \"Test Suite Mgt.\";\n        Counter: Integer;\n        NoCodeLines: Integer;\n        NoCodeLinesHit: Integer;\n        TestCodeunit: Integer;\n        JsonArray: JsonArray;\n        JsonObject: JsonObject;\n        JsonToken: JsonToken;\n        JsonTokenName: JsonToken;\n        JsonTokenTestCodeunit: JsonToken;\n        JsonNameMissingErr: Label 'json element at position %1 have no name', Locked = true, Comment = '%1 = position of element starting with 0';\n        JsonTestCodeunitMissingErr: Label 'json element at position %1 have no test codeunit id', Locked = true, Comment = '%1 = position of element starting with 0';\n        JsonTestNotAnArrayAsExpectedErr: Label 'Parameter test not a json array as expected', Locked = true;\n        TestName: Text;\n    begin\n        if not JsonArray.ReadFrom(JsonTests) then\n            Error(JsonTestNotAnArrayAsExpectedErr);\n\n        NewTestSuite(TestSuiteName);  // Skips if exist\n        ALTestSuite.Get(TestSuiteName);\n        ALTestSuite.IsRunning := true;\n        ALTestSuite.Modify();\n\n        // Enable Code Coverage\n        if BuildMapping then begin\n            ALTestSuite.Validate(\"CC Coverage Map\", ALTestSuite.\"CC Coverage Map\"::Disabled);  //Using own codevarage\n            ALTestSuite.Modify(true)\n        end;\n\n        Counter := 1;\n        foreach JsonToken in JsonArray do begin\n            JsonObject := JsonToken.AsObject();\n            if not JsonObject.Get(TestMethodLine.FieldName(Name), JsonTokenName) then\n                Error(JsonNameMissingErr, Counter);\n            TestName := JsonTokenName.AsValue().AsText();\n\n            if not JsonObject.Get(TestMethodLine.FieldName(\"Test Codeunit\"), JsonTokenTestCodeunit) then\n                Error(JsonTestCodeunitMissingErr, Counter);\n            TestCodeunit := JsonTokenTestCodeunit.AsValue().AsInteger();\n\n            // Defensive implementierung. Sollte der Test fehlen wird er hinzugefügt anstatt einer Fehlermeldung.\n            TestMethodLine.Reset();\n            TestMethodLine.SetRange(\"Test Suite\", TestSuiteName);\n            TestMethodLine.SetRange(Name, TestName);\n            TestMethodLine.SetRange(\"Test Codeunit\", TestCodeunit);\n            if TestMethodLine.IsEmpty() then\n                AddTests(TestSuiteName, TestCodeunit, TestCodeunit);\n\n            TestMethodLine.Reset();\n            TestMethodLine.SetRange(\"Test Suite\", TestSuiteName);\n            TestMethodLine.SetRange(Name, TestName);\n            TestMethodLine.SetRange(\"Test Codeunit\", TestCodeunit);\n\n            if BuildMapping then begin\n                Clear(CodeCoverageMgt);\n                CodeCoverageMgt.Start(false);\n            end;\n\n            TestSuiteMgt.RunSelectedTests(TestMethodLine);\n\n            if BuildMapping then begin\n                CodeCoverageMgt.Stop();\n\n                ObjectTestMapping.Reset();\n                ObjectTestMapping.SetRange(TestSuite, TestSuiteName);\n                ObjectTestMapping.SetRange(Name, TestName);\n                ObjectTestMapping.SetRange(TestCodeunit, TestCodeunit);\n                ObjectTestMapping.DeleteAll(true);\n                CodeCoverage.Reset();\n                CodeCoverageMgt.ObjectCoverage(CodeCoverage, NoCodeLines, NoCodeLinesHit);\n                //CodeCoverage.SetRange(\"Line Type\", CodeCoverage.\"Line Type\"::Object);\n                CodeCoverage.SetLoadFields(\"Object Type\", \"Object ID\");\n                if CodeCoverage.FindSet(false) then\n                    repeat\n                        ObjectTestMapping.Init();\n                        ObjectTestMapping.TestSuite := CopyStr(TestSuiteName, 1, MaxStrLen(ObjectTestMapping.TestSuite));\n                        ObjectTestMapping.Name := CopyStr(TestName, 1, MaxStrLen(ObjectTestMapping.Name));\n                        ObjectTestMapping.TestCodeunit := TestCodeunit;\n                        ObjectTestMapping.ObjectType := CodeCoverage.\"Object Type\";\n                        ObjectTestMapping.ObjectId := CodeCoverage.\"Object ID\";\n                        if ObjectTestMapping.Insert(true) then;\n                    until CodeCoverage.Next() = 0;\n            end;\n            Counter += 1;\n        end;\n\n        ALTestSuite.IsRunning := false;\n        ALTestSuite.Modify();\n    end;\n\n    [ServiceEnabled]\n    procedure GetTestRunningStatus(TestSuiteName: Text) JsonResult: Text\n    var\n        AlTestSuite: Record \"AL Test Suite\";\n        IsRunning: Boolean;\n    begin\n        IsRunning := false;\n        if AlTestSuite.Get(TestSuiteName) then\n            IsRunning := AlTestSuite.IsRunning;\n\n        if IsRunning then\n            JsonResult := '{\"status\": \"running\"}'\n        else\n            JsonResult := '{\"status\": \"completed\"}';\n    end;\n\n    [ServiceEnabled]\n    procedure GetRebuildStatus(TestSuiteName: Text) JsonResult: Text\n    var\n        AlTestSuite: Record \"AL Test Suite\";\n        IsRebuilding: Boolean;\n    begin\n        IsRebuilding := false;\n        if AlTestSuite.Get(TestSuiteName) then\n            IsRebuilding := AlTestSuite.IsRebuilding;\n\n        if IsRebuilding then\n            JsonResult := '{\"status\": \"running\"}'\n        else\n            JsonResult := '{\"status\": \"completed\"}';\n    end;\n\n    [ServiceEnabled]\n    procedure RebuildAllMappings(TestSuiteName: Text; CodeunitFilter: Text) JsonResult: Text\n    var\n        ObjectTestMapping: Record ObjectTestMapping;\n        TestMethodLine: Record \"Test Method Line\";\n        AlTestSuite: Record \"AL Test Suite\";\n        JsonTest: Text;\n    begin\n        NewTestSuite(TestSuiteName);  // Skips if exist\n        AlTestSuite.Get(TestSuiteName);\n        AlTestSuite.IsRebuilding := true;\n        AlTestSuite.Modify(true);\n\n        TestMethodLine.Reset();\n        TestMethodLine.SetRange(\"Test Suite\", TestSuiteName);\n        TestMethodLine.DeleteAll(true);\n\n        ObjectTestMapping.Reset();\n        ObjectTestMapping.SetRange(TestSuite, TestSuiteName);\n        ObjectTestMapping.DeleteAll(true);\n\n        AddTests(TestSuiteName, CodeunitFilter);\n        JsonTest := GetTests(CodeunitFilter);\n        ApplyTests(TestSuiteName, JsonTest, true);\n\n        AlTestSuite.IsRebuilding := false;\n        AlTestSuite.Modify(true);\n    end;\n\n    [ServiceEnabled]\n    procedure ImportObjectTestMapping(TestSuiteName: Text; JsonObjectTestMapping: Text) JsonResult: Text\n    var\n        ObjectTestMapping: Record ObjectTestMapping;\n        Counter: Integer;\n        JsonArray: JsonArray;\n        JsonObject: JsonObject;\n        JsonToken: JsonToken;\n        JsonToken2: JsonToken;\n        JsonNameMissingErr: Label 'json element at position %1 have no %2', Locked = true, Comment = '%1 = position of element starting with 0, %2=element name';\n        JsonTestNotAnArrayAsExpectedErr: Label 'Parameter test not a json array as expected', Locked = true;\n    begin\n        if not JsonArray.ReadFrom(JsonObjectTestMapping) then\n            Error(JsonTestNotAnArrayAsExpectedErr);\n\n        ObjectTestMapping.Reset();\n        ObjectTestMapping.SetRange(TestSuite, TestSuiteName);\n        ObjectTestMapping.DeleteAll(true);\n\n        Counter := 1;\n        foreach JsonToken in JsonArray do begin\n            JsonObject := JsonToken.AsObject();\n\n            if not JsonObject.Get(ObjectTestMapping.FieldName(ObjectId), JsonToken2) then\n#pragma warning disable AA0448\n                Error(JsonNameMissingErr, Counter, ObjectTestMapping.FieldName(ObjectId));\n            ObjectTestMapping.ObjectId := JsonToken2.AsValue().AsInteger();\n\n            if not JsonObject.Get(ObjectTestMapping.FieldName(ObjectType), JsonToken2) then\n                Error(JsonNameMissingErr, Counter, ObjectTestMapping.FieldName(ObjectType));\n            ObjectTestMapping.ObjectType := JsonToken2.AsValue().AsInteger();\n\n            if not JsonObject.Get(ObjectTestMapping.FieldName(TestSuite), JsonToken2) then\n                Error(JsonNameMissingErr, Counter, ObjectTestMapping.FieldName(TestSuite));\n            ObjectTestMapping.TestSuite := CopyStr(JsonToken2.AsValue().AsText(), 1, MaxStrLen(ObjectTestMapping.TestSuite));\n\n            if not JsonObject.Get(ObjectTestMapping.FieldName(TestCodeunit), JsonToken2) then\n                Error(JsonNameMissingErr, Counter, ObjectTestMapping.FieldName(TestCodeunit));\n            ObjectTestMapping.TestCodeunit := JsonToken2.AsValue().AsInteger();\n\n            if not JsonObject.Get(ObjectTestMapping.FieldName(Name), JsonToken2) then\n                Error(JsonNameMissingErr, Counter, ObjectTestMapping.FieldName(Name));\n            ObjectTestMapping.Name := CopyStr(JsonToken2.AsValue().AsText(), 1, MaxStrLen(ObjectTestMapping.Name));\n#pragma warning restore AA0448            \n            if ObjectTestMapping.Insert(true) then;\n            Counter += 1;\n        end;\n    end;\n\n    [ServiceEnabled]\n    procedure ExportObjectTestMapping(TestSuiteName: Text) JsonResult: Text\n    var\n        ObjectTestMapping: Record ObjectTestMapping;\n        JsonArray: JsonArray;\n        JsonObject: JsonObject;\n    begin\n        ObjectTestMapping.Reset();\n        ObjectTestMapping.SetRange(TestSuite, TestSuiteName);\n        if ObjectTestMapping.FindSet(false) then\n            repeat\n                Clear(JsonObject);\n                JsonObject.Add(ObjectTestMapping.FieldName(ObjectId), ObjectTestMapping.ObjectId);\n                JsonObject.Add(ObjectTestMapping.FieldName(ObjectType), ObjectTestMapping.ObjectType);\n                JsonObject.Add(ObjectTestMapping.FieldName(TestSuite), ObjectTestMapping.TestSuite);\n                JsonObject.Add(ObjectTestMapping.FieldName(TestCodeunit), ObjectTestMapping.TestCodeunit);\n                JsonObject.Add(ObjectTestMapping.FieldName(Name), ObjectTestMapping.Name);\n                JsonArray.Add(JsonObject);\n            until ObjectTestMapping.Next() = 0;\n\n        JsonArray.WriteTo(JsonResult);\n        exit(JsonResult);\n    end;\n}"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "{\n  \"name\": \"business-central-al-test-runner\",\n  \"displayName\": \"Business Central AL Test Runner\",\n  \"description\": \"A Visual Studio Code extension to run automated tests for Business Central AL.\",\n  \"publisher\": \"KonnosPB\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.90.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onCommand:bc-testrunner.runTests\",\n    \"onCommand:bc-testrunner.clearCredentials\",\n    \"onCommand:bc-testrunner.selectTestSuite\",\n    \"onCommand:bc-testrunner.exportObjectTestMapping\",\n    \"onCommand:bc-testrunner.importObjectTestMapping\",\n    \"onCommand:bc-testrunner.rebuildAllMappings\",\n    \"onCommand:bc-testrunner.applyTests\",\n    \"onCommand:bc-testrunner.runTestsMenu\",\n    \"onView:bcTestRunner\",\n    \"onView:selectiveTestsView\",\n    \"onView:allTestsView\",    \n    \"onStartupFinished\",\n    \"onView:scm\",\n    \"workspaceContains:app.json\",\n    \"workspaceContains:.alpackages\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"bc-testrunner.runTests\",\n        \"title\": \"bc-testrunner: Run Business Central AL Tests\"\n      },\n      {\n        \"command\": \"bc-testrunner.clearCredentials\",\n        \"title\": \"bc-testrunner: Clear Business Central Credentials\"\n      },\n      {\n        \"command\": \"bc-testrunner.selectTestSuite\",\n        \"title\": \"bc-testrunner: Select or Create Business Central TestSuite\"\n      },\n      {\n        \"command\": \"bc-testrunner.exportObjectTestMapping\",\n        \"title\": \"bc-testrunner: Export Object-Test Mapping\"\n      },\n      {\n        \"command\": \"bc-testrunner.importObjectTestMapping\",\n        \"title\": \"bc-testrunner: Import Object-Test Mapping\"\n      },\n      {\n        \"command\": \"bc-testrunner.rebuildAllMappings\",\n        \"title\": \"bc-testrunner: Rebuild All Mappings\"\n      },\n      {\n        \"command\": \"bc-testrunner.applyTests\",\n        \"title\": \"bc-testrunner: Apply Tests\"\n      },\n      {\n        \"command\": \"bc-testrunner.refreshSelectiveTests\",\n        \"title\": \"bc-testrunner: Refresh Selective Tests\"\n      },\n      {\n        \"command\": \"bc-testrunner.refreshAllTests\",\n        \"title\": \"bc-testrunner: Refresh All Tests\"\n      },\n      {\n        \"command\": \"bc-testrunner.runTestsMenu\", \n        \"title\": \"bc-testrunner: Test changes\",        \n        \"icon\" : \"$(beaker)\"\n      },\n      {\n        \"command\": \"bc-testrunner.publishAppAndTestapp\",\n        \"title\": \"bc-testrunner: Publish app & testapp\"\n      },\n      {\n        \"command\": \"bc-testrunner.publishTestapp\", \n        \"title\": \"bc-testrunner: Publish testapp\"\n      }\n    ],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"bcTestRunner\",\n          \"title\": \"BC Test Runner\",\n          \"icon\": \"resources/test-svgrepo-com.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"bcTestRunner\": [       \n        {\n          \"id\": \"allTestsView\",\n          \"name\": \"All Tests\"\n        }\n      ],\n      \"scm\": [\n        {\n          \"id\": \"selectiveTestsView\",\n          \"name\": \"Test changes\"\n        }\n      ]\n    },\n    \"menus\": {\n      \"scm/title\": [\n        {\n          \"command\": \"bc-testrunner.runTestsMenu\",\n          \"group\": \"navigation\",\n          \"when\": \"scmProvider == git\",\n          \"title\": \"Test changes\",\n          \"icon\": \"$(beaker)\"\n        }\n      ]\n    }\n  },\n  \"dependencies\": {\n    \"axios\": \"^1.7.2\"\n  },\n  \"extensionDependencies\": [\n    \"vscode.git\"\n  ],\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"vscode-test\",\n    \"format\": \"prettier --write 'src/**/*.ts'\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.90.0\",\n    \"@types/mocha\": \"^10.0.6\",\n    \"@types/node\": \"20.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^7.11.0\",\n    \"@typescript-eslint/parser\": \"^7.11.0\",\n    \"eslint\": \"^8.57.0\",\n    \"typescript\": \"^5.4.5\",\n    \"@vscode/test-cli\": \"^0.0.9\",\n    \"@vscode/test-electron\": \"^2.4.0\",\n    \"prettier\": \"^3.0.0\"\n  }\n}"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "// apiClient.ts\n\nimport axios from 'axios';\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface Credentials {\n    username: string;\n    password: string;\n}\n\n\nexport const getTestSuites = async (context: vscode.ExtensionContext) => {\n    const client = await apiClient(context);\n    const response = await client.get('/getTestSuites');\n    return response.data;\n};\n\nexport const createTestSuite = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    const client = await apiClient(context);\n    const response = await client.post('/newTestSuite', { TestSuiteName: testSuiteName });\n    return response.data;\n};\n\nexport async function getBaseURL(): Promise<string> {\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const launchJsonPath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'launch.json');\n    if (!fs.existsSync(launchJsonPath)) {\n        throw new Error('launch.json not found.');\n    }\n\n    const launchJson = JSON.parse(fs.readFileSync(launchJsonPath, 'utf8'));\n    const configurations = launchJson.configurations;\n\n    if (configurations.length === 0) {\n        throw new Error('No configurations found in launch.json.');\n    }\n\n    let selectedConfiguration = configurations[0];\n    if (configurations.length > 1) {\n        const configurationNames = configurations.map((config: any) => config.name);\n        const selectedName = await vscode.window.showQuickPick(configurationNames, {\n            placeHolder: 'Select a launch configuration'\n        });\n\n        if (!selectedName) {\n            throw new Error('No configuration selected.');\n        }\n\n        selectedConfiguration = configurations.find((config: any) => config.name === selectedName);\n    }\n\n    return selectedConfiguration.url;\n}\n\nexport async function getLaunchConfigAndTenant(): Promise<{ name: string; tenant: string }> {\n    const launchConfig = await getLaunchConfig();\n    let tenant = launchConfig.tenant;\n\n    if (!tenant) {\n        tenant = await vscode.window.showInputBox({ prompt: 'Enter the tenant' });\n        if (!tenant) {\n            throw new Error('Tenant is required.');\n        }\n    }\n\n    return { name: launchConfig.name, tenant };\n}\n\nasync function getLaunchConfig(): Promise<{ name: string, tenant?: string }> {\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const launchJsonPath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'launch.json');\n    if (!fs.existsSync(launchJsonPath)) {\n        throw new Error('launch.json not found.');\n    }\n\n    try {\n        const launchJson = JSON.parse(fs.readFileSync(launchJsonPath, 'utf8'));\n        const configurations = launchJson.configurations;\n\n        if (configurations.length === 0) {\n            throw new Error('No configurations found in launch.json.');\n        }\n\n        let selectedConfiguration = configurations[0];\n        if (configurations.length > 1) {\n            const configurationNames = configurations.map((config: any) => config.name);\n            const selectedName = await vscode.window.showQuickPick(configurationNames, {\n                placeHolder: 'Select a launch configuration'\n            });\n\n            if (!selectedName) {\n                throw new Error('No configuration selected.');\n            }\n\n            selectedConfiguration = configurations.find((config: any) => config.name === selectedName);\n        }\n\n        return {\n            name: selectedConfiguration.name,\n            tenant: selectedConfiguration.tenant\n        };\n    } catch (error) {\n        if (error instanceof Error) {\n            throw new Error(`Error parsing launch.json: ${error.message}`);\n        } else {\n            throw new Error('Unknown error occurred while parsing launch.json.');\n        }\n    }\n}\n\nfunction getSecretStoreKey(baseURL: string): string {\n    return `businessCentralCredentials:${baseURL}`;\n}\n\nasync function getCredentials(context: vscode.ExtensionContext, baseURL: string): Promise<Credentials> {\n    const secretStoreKey = getSecretStoreKey(baseURL);\n    const secret = await context.secrets.get(secretStoreKey);\n    if (secret) {\n        return JSON.parse(secret);\n    }\n\n    const username = await vscode.window.showInputBox({ prompt: 'Enter your Business Central username' });\n    if (!username) {\n        throw new Error('Username is required.');\n    }\n\n    const password = await vscode.window.showInputBox({ prompt: 'Enter your Business Central password', password: true });\n    if (!password) {\n        throw new Error('Password is required.');\n    }\n\n    const credentials: Credentials = { username, password };\n    await context.secrets.store(secretStoreKey, JSON.stringify(credentials));\n\n    return credentials;\n}\n\nexport async function clearCredentials(context: vscode.ExtensionContext, baseURL: string) {\n    const secretStoreKey = getSecretStoreKey(baseURL);\n    await context.secrets.delete(secretStoreKey);\n    vscode.window.showInformationMessage(`Credentials for ${baseURL} cleared.`);\n}\n\nasync function createApiClient(context: vscode.ExtensionContext) {\n    const baseURL = await getBaseURL();\n    const credentials = await getCredentials(context, baseURL);\n\n    return axios.create({\n        baseURL,\n        auth: {\n            username: credentials.username,\n            password: credentials.password\n        }\n    });\n}\n\nexport async function apiClient(context: vscode.ExtensionContext) {\n    return await createApiClient(context);\n}\n\nexport const ping = async (context: vscode.ExtensionContext) => {\n    const client = await apiClient(context);\n    const response = await client.get('/ping');\n    return response.data;\n};\n\nexport const addTests = async (context: vscode.ExtensionContext, testSuiteName: string, fromId: number, toId: number) => {\n    const client = await apiClient(context);\n    const response = await client.post('/addTests', { TestSuiteName: testSuiteName, FromId: fromId, ToId: toId });\n    return response.data;\n};\n\nexport const getTests = async (context: vscode.ExtensionContext, testSuiteName: string, changedFiles: string[]) => {\n    const client = await apiClient(context);\n    const response = await client.post('/getTests', { TestSuiteName: testSuiteName, ChangedFiles: changedFiles });\n    return response.data;\n};\n\nexport const applyTests = async (context: vscode.ExtensionContext, testSuiteName: string, jsonTests: string, buildMapping: boolean) => {\n    const client = await apiClient(context);\n    const response = await client.post('/applyTests', { TestSuiteName: testSuiteName, JsonTests: jsonTests, BuildMapping: buildMapping });\n    return response.data;\n};\n\nlet codeunitFilter: string | undefined;\n\nasync function getCodeunitFilter(): Promise<string> {\n    if (codeunitFilter) {\n        return codeunitFilter;\n    }\n\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const workspacePath = workspaceFolders[0].uri.fsPath;\n\n    // Check AppSourceCop.json\n    const appSourceCopPath = path.join(workspacePath, 'AppSourceCop.json');\n    if (fs.existsSync(appSourceCopPath)) {\n        const appSourceCop = JSON.parse(fs.readFileSync(appSourceCopPath, 'utf8'));\n        if (appSourceCop.mandatoryPrefix) {\n            codeunitFilter = `${appSourceCop.mandatoryPrefix}*`;\n            return codeunitFilter;\n        }\n    }\n\n    // Check settings.json\n    const settingsPath = path.join(workspacePath, '.vscode', 'settings.json');\n    if (fs.existsSync(settingsPath)) {\n        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n        if (settings['aladdin-insider.xliff.project']) {\n            codeunitFilter = `${settings['aladdin-insider.xliff.project']}*`;\n            return codeunitFilter;\n        }\n        if (settings['CRS.ObjectNamePrefix']) {\n            codeunitFilter = `${settings['CRS.ObjectNamePrefix']}*`;\n            return codeunitFilter;\n        }\n    }\n\n    // Ask the user for the prefix if not found\n    const userInput = await vscode.window.showInputBox({ prompt: 'Enter the Codeunit prefix' });\n    if (!userInput) {\n        throw new Error('Codeunit prefix is required.');\n    }\n    codeunitFilter = `${userInput}*`;\n    return codeunitFilter;\n}\n\nexport const rebuildAllMappings = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    const client = await apiClient(context);\n    const codeunitFilter = await getCodeunitFilter();\n    const response = await client.post('/rebuildAllMappings', { TestSuiteName: testSuiteName, CodeunitFilter: codeunitFilter });\n    return response.data;\n};\n\nexport const getRebuildStatus = async (context: vscode.ExtensionContext) => {\n    const client = await apiClient(context);\n    const response = await client.get('/GetRebuildStatus');\n    return response.data;\n};\n\nexport const getTestRunningStatus = async (context: vscode.ExtensionContext) => {\n    const client = await apiClient(context);\n    const response = await client.get('/GetTestRunningStatus');\n    return response.data;\n};\n\nexport const exportObjectTestMappingToFile = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    const client = await apiClient(context);\n    const jsonResult = await client.get(`/exportObjectTestMapping?TestSuiteName=${testSuiteName}`);\n\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const filePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'object-test-mapping.json');\n    fs.writeFileSync(filePath, JSON.stringify(jsonResult, null, 2));\n\n    vscode.window.showInformationMessage(`Object-Test Mapping exported to ${filePath}`);\n};\n\nexport const exportObjectTestMapping = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    const client = await apiClient(context);\n    const jsonResult = await client.get(`/exportObjectTestMapping?TestSuiteName=${testSuiteName}`);\n\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const filePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'object-test-mapping.json');\n    fs.writeFileSync(filePath, JSON.stringify(jsonResult, null, 2));\n\n    vscode.window.showInformationMessage(`Object-Test Mapping exported to ${filePath}`);\n};\n\n\nexport const importObjectTestMappingFromFile = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const filePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'object-test-mapping.json');\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`File ${filePath} does not exist.`);\n    }\n\n    const jsonObjectTestMapping = fs.readFileSync(filePath, 'utf8');\n    const client = await apiClient(context);\n    await client.post('/importObjectTestMapping', { TestSuiteName: testSuiteName, JsonObjectTestMapping: jsonObjectTestMapping });\n\n    vscode.window.showInformationMessage(`Object-Test Mapping imported from ${filePath}`);\n};\n\nexport const getGitChanges = async (): Promise<string[]> => {\n    const gitExtension = vscode.extensions.getExtension('vscode.git')?.exports;\n    const api = gitExtension.getAPI(1);\n\n    const repository = api.repositories[0];\n    const changes = repository.state.workingTreeChanges;\n\n    return changes.map((change: vscode.SourceControlResourceState) => change.resourceUri.fsPath);\n};"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "// project.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as child_process from 'child_process';\n\nlet testAppPath: string | undefined;\n\nasync function findTestAppPath(): Promise<string> {\n    if (testAppPath) {\n        return testAppPath;\n    }\n\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n        throw new Error('No workspace folder is open.');\n    }\n\n    const testAppFolder = workspaceFolders.find(folder => {\n        const appJsonPath = path.join(folder.uri.fsPath, 'app.json');\n        if (fs.existsSync(appJsonPath)) {\n            const appJson = JSON.parse(fs.readFileSync(appJsonPath, 'utf8'));\n            return appJson.dependencies && appJson.dependencies.some((dep: any) => dep.name === 'Tests-TestLibraries');\n        }\n        return false;\n    });\n\n    if (testAppFolder) {\n        testAppPath = testAppFolder.uri.fsPath;\n        return testAppPath;\n    }\n\n    const selectedFolder = await vscode.window.showOpenDialog({\n        canSelectFolders: true,\n        openLabel: 'Select Test App Folder'\n    });\n\n    if (!selectedFolder || selectedFolder.length === 0) {\n        throw new Error('No folder selected.');\n    }\n\n    testAppPath = selectedFolder[0].fsPath;\n    return testAppPath;\n}\n\nasync function modifyLaunchJson(testAppFolder: string, appFolder: string) {\n    const launchJsonPath = path.join(testAppFolder, '.vscode', 'launch.json');\n    const appLaunchJsonPath = path.join(appFolder, '.vscode', 'launch.json');\n\n    if (!fs.existsSync(appLaunchJsonPath)) {\n        throw new Error('launch.json not found in the app folder.');\n    }\n\n    const appLaunchJson = JSON.parse(fs.readFileSync(appLaunchJsonPath, 'utf8'));\n    const appConfiguration = appLaunchJson.configurations[0]; // Assuming the first configuration is the one we need\n\n    if (!fs.existsSync(launchJsonPath)) {\n        fs.writeFileSync(launchJsonPath, JSON.stringify({ configurations: [appConfiguration] }, null, 2));\n    } else {\n        const launchJson = JSON.parse(fs.readFileSync(launchJsonPath, 'utf8'));\n        launchJson.configurations.push(appConfiguration);\n        fs.writeFileSync(launchJsonPath, JSON.stringify(launchJson, null, 2));\n    }\n}\n\nexport async function publishTestapp(context: vscode.ExtensionContext) {\n    try {\n        const testAppFolder = await findTestAppPath();\n        const appFolder = vscode.workspace.workspaceFolders?.[0].uri.fsPath;\n\n        if (!appFolder) {\n            throw new Error('No app folder found.');\n        }\n\n        await modifyLaunchJson(testAppFolder, appFolder);\n\n        const vsCodePath = 'code'; // Path to the Visual Studio Code executable\n        const newInstanceArgs = [\n            testAppFolder,\n            '--new-window',\n            //'--disable-extensions',\n            '--user-data-dir', path.join(testAppFolder, '.vscode-test-user-data'),\n            '--disable-workspace-trust'\n        ];\n\n        const newInstance = child_process.spawn(vsCodePath, newInstanceArgs, {\n            stdio: 'inherit',\n            shell: true\n        });\n\n        newInstance.on('close', async (code) => {\n            if (code === 0) {\n                await vscode.commands.executeCommand('al.publishWithoutDebugging', { folderPath: testAppFolder });\n                vscode.window.showInformationMessage('Testapp published successfully.');\n                newInstance.kill();\n            } else {\n                vscode.window.showErrorMessage(`Failed to open new VS Code instance with code ${code}`);\n            }\n        });\n    } catch (error) {\n        vscode.window.showErrorMessage(error instanceof Error ? error.message : String(error));\n    }\n}"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "// testRunner.ts\n\nimport * as vscode from 'vscode';\nimport { getTests, applyTests, getGitChanges } from './apiClient';\n\nexport const runTests = async (context: vscode.ExtensionContext, testSuiteName: string) => {\n    // 1. Via git die Objektids der modifizierten Objekte ermitteln\n    const changedFiles = await getGitChanges();\n\n    // 2. Via Web API die zugehörigen Tests anhand des Objektmappings ermitteln\n    const jsonTests = await getTests(context, testSuiteName, changedFiles);\n\n    // 3. Die Testfälle in der View anzeigen und der Test gestartet\n    const buildMapping = true;\n    const result = await applyTests(context, testSuiteName, jsonTests, buildMapping);\n\n    // Parse the result to get the summary of test outcomes\n    const testResults = JSON.parse(result);\n    const totalTests = testResults.length;\n    const passedTests = testResults.filter((test: any) => test.status === 'Passed').length;\n    const failedTests = testResults.filter((test: any) => test.status === 'Failed').length;\n\n    vscode.window.showInformationMessage(`Tests executed: ${totalTests}, Passed: ${passedTests}, Failed: ${failedTests}`);\n};"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "// testViewProviders.ts\nimport * as vscode from 'vscode';\nimport { getLaunchConfigAndTenant } from './apiClient';\n\nclass TestItem extends vscode.TreeItem {\n    constructor(\n        public readonly label: string,\n        public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n        public readonly command?: vscode.Command,\n        public readonly contextValue?: string,\n        public readonly iconPath?: vscode.ThemeIcon\n    ) {\n        super(label, collapsibleState);\n        if (iconPath) {\n            this.iconPath = iconPath;\n        }\n    }\n}\n\nexport class SelectiveTestsProvider implements vscode.TreeDataProvider<TestItem> {\n    private _onDidChangeTreeData: vscode.EventEmitter<TestItem | undefined | void> = new vscode.EventEmitter<TestItem | undefined | void>();\n    readonly onDidChangeTreeData: vscode.Event<TestItem | undefined | void> = this._onDidChangeTreeData.event;\n\n    constructor(private context: vscode.ExtensionContext) {}\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire();\n    }\n\n    getTreeItem(element: TestItem): vscode.TreeItem {\n        return element;\n    }\n\n    getChildren(element?: TestItem): Thenable<TestItem[]> {\n        if (!element) {\n            // Root elements\n            return this.getTestSuites();\n        } else {\n            // Child elements\n            return this.getTests(element);\n        }\n    }\n\n    private async getTestSuites(): Promise<TestItem[]> {\n        try {\n            const { name, tenant } = await getLaunchConfigAndTenant();\n            // Format the label as \"name (tenant)\" and add the Beaker icon\n            const label = `${name} (${tenant})`;\n            return [new TestItem(label, vscode.TreeItemCollapsibleState.Collapsed, undefined, undefined, new vscode.ThemeIcon('beaker'))];\n        } catch (error) {            \n            if (error instanceof Error) {\n                vscode.window.showErrorMessage(`Error fetching launch configuration: ${error.message}`);\n            } else {\n                throw new Error('Unknown error occurred while fetching launch.json.');\n            }   \n            return [];\n        }\n    }\n\n    private async getTests(testSuite: TestItem): Promise<TestItem[]> {\n        // Fetch tests from API\n        return [];\n    }\n}\n\nexport class AllTestsProvider implements vscode.TreeDataProvider<TestItem> {\n    private _onDidChangeTreeData: vscode.EventEmitter<TestItem | undefined | void> = new vscode.EventEmitter<TestItem | undefined | void>();\n    readonly onDidChangeTreeData: vscode.Event<TestItem | undefined | void> = this._onDidChangeTreeData.event;\n\n    constructor(private context: vscode.ExtensionContext) {}\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire();\n    }\n\n    getTreeItem(element: TestItem): vscode.TreeItem {\n        return element;\n    }\n\n    getChildren(element?: TestItem): Thenable<TestItem[]> {\n        if (!element) {\n            // Root elements\n            return this.getTestSuites();\n        } else {\n            // Child elements\n            return this.getTests(element);\n        }\n    }\n\n    private async getTestSuites(): Promise<TestItem[]> {\n        try {\n            const { name, tenant } = await getLaunchConfigAndTenant();\n            // Format the label as \"name (tenant)\" and add the Beaker icon\n            const label = `${name} (${tenant})`;\n            return [new TestItem(label, vscode.TreeItemCollapsibleState.Collapsed, undefined, undefined, new vscode.ThemeIcon('beaker'))];\n        } catch (error) {\n            if (error instanceof Error) {\n                vscode.window.showErrorMessage(`Error fetching launch configuration: ${error.message}`);\n            } else {\n                throw new Error('Unknown error occurred while fetching launch.json.');\n            }            \n            return [];\n        }\n    }\n\n    private async getTests(testSuite: TestItem): Promise<TestItem[]> {\n        // Fetch tests from API\n        return [];\n    }\n}"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "import * as vscode from 'vscode';\nimport { runTests } from './testRunner';\nimport { clearCredentials, getBaseURL, getTestSuites, createTestSuite, exportObjectTestMappingToFile, importObjectTestMappingFromFile, getRebuildStatus, getTestRunningStatus, rebuildAllMappings, applyTests, getTests, getGitChanges } from './apiClient';\nimport { SelectiveTestsProvider, AllTestsProvider } from './testViewProviders';\nimport { publishAppAndTestapp, publishTestapp } from './project';\n\nlet selectedTestSuite: string | undefined;\n\nasync function selectOrCreateTestSuite(context: vscode.ExtensionContext): Promise<string> {\n    if (selectedTestSuite) {\n        return selectedTestSuite;\n    }\n\n    const testSuites = await getTestSuites(context);\n\n    const options = testSuites.map((suite: any) => suite.name);\n    options.push('Create new TestSuite');\n\n    const selectedOption = await vscode.window.showQuickPick(options, {\n        placeHolder: 'Select a TestSuite or create a new one'\n    });\n\n    if (!selectedOption) {\n        throw new Error('No TestSuite selected.');\n    }\n\n    if (selectedOption === 'Create new TestSuite') {\n        const newTestSuiteName = await vscode.window.showInputBox({ prompt: 'Enter the name of the new TestSuite' });\n        if (!newTestSuiteName) {\n            throw new Error('TestSuite name is required.');\n        }\n        await createTestSuite(context, newTestSuiteName);\n        selectedTestSuite = newTestSuiteName;\n    } else {\n        selectedTestSuite = selectedOption;\n    }\n\n    return selectedTestSuite;\n}\n\nasync function monitorStatus(context: vscode.ExtensionContext, statusFunction: () => Promise<boolean>, message: string) {\n    const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);\n    statusBarItem.text = message;\n    statusBarItem.show();\n\n    let status = await statusFunction();\n    while (status) {\n        await new Promise(resolve => setTimeout(resolve, 10000)); // Check every 10 seconds\n        status = await statusFunction();\n    }\n\n    statusBarItem.hide();\n    statusBarItem.dispose();\n    vscode.window.showInformationMessage(`${message} completed.`);\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.info(\"Business Central AL Test Runner: Activating\");\n    let runTestsCommand = vscode.commands.registerCommand('bc-testrunner.runTests', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        runTests(context, testSuite);\n    });\n\n    let runTestsMenuCommand = vscode.commands.registerCommand('bc-testrunner.runTestsMenu', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        runTests(context, testSuite);\n    });\n\n    let clearCredentialsCommand = vscode.commands.registerCommand('bc-testrunner.clearCredentials', async () => {\n        const baseURL = await getBaseURL();\n        await clearCredentials(context, baseURL);\n    });\n\n    let selectTestSuiteCommand = vscode.commands.registerCommand('bc-testrunner.selectTestSuite', async () => {\n        selectedTestSuite = undefined; // Reset the selected TestSuite\n        await selectOrCreateTestSuite(context);\n    });\n\n    let exportMappingCommand = vscode.commands.registerCommand('bc-testrunner.exportObjectTestMapping', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        await exportObjectTestMappingToFile(context, testSuite);\n    });\n\n    let importMappingCommand = vscode.commands.registerCommand('bc-testrunner.importObjectTestMapping', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        await importObjectTestMappingFromFile(context, testSuite);\n    });\n\n    let rebuildAllMappingsCommand = vscode.commands.registerCommand('bc-testrunner.rebuildAllMappings', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        const rebuildStatus = await getRebuildStatus(context);\n        if (rebuildStatus) {\n            vscode.window.showWarningMessage('Rebuild process is already running.');\n            return;\n        }\n\n        vscode.window.withProgress({\n            location: vscode.ProgressLocation.Notification,\n            title: \"Rebuilding All Mappings\",\n            cancellable: false\n        }, async (progress) => {\n            progress.report({ increment: 0, message: \"Starting rebuild process...\" });\n\n            // Call the rebuild function\n            await rebuildAllMappings(context, testSuite);\n\n            // Monitor the status\n            await monitorStatus(context, async () => await getRebuildStatus(context), \"Rebuilding All Mappings\");\n\n            progress.report({ increment: 100, message: \"Rebuild process completed.\" });\n        });\n    });\n\n    let applyTestsCommand = vscode.commands.registerCommand('bc-testrunner.applyTests', async () => {\n        const testSuite = await selectOrCreateTestSuite(context);\n        const testRunningStatus = await getTestRunningStatus(context);\n        if (testRunningStatus) {\n            vscode.window.showWarningMessage('Test running process is already running.');\n            return;\n        }\n\n        const changedFiles = await getGitChanges();\n        const jsonTests = await getTests(context, testSuite, changedFiles);\n\n        vscode.window.withProgress({\n            location: vscode.ProgressLocation.Notification,\n            title: \"Applying Tests\",\n            cancellable: false\n        }, async (progress) => {\n            progress.report({ increment: 0, message: \"Starting test process...\" });\n\n            // Call the apply tests function\n            await applyTests(context, testSuite, jsonTests, true);\n\n            // Monitor the status\n            await monitorStatus(context, async () => await getTestRunningStatus(context), \"Applying Tests\");\n\n            progress.report({ increment: 100, message: \"Test process completed.\" });\n        });\n    });\n\n    const publishAppAndTestappCommand = vscode.commands.registerCommand('bc-testrunner.publishAppAndTestapp', async () => {\n        await publishAppAndTestapp(context);\n    });\n\n    const publishTestappCommand = vscode.commands.registerCommand('bc-testrunner.publishTestapp', async () => {\n        await publishTestapp(context);\n    });\n\n    context.subscriptions.push(runTestsCommand);\n    context.subscriptions.push(runTestsMenuCommand);\n    context.subscriptions.push(clearCredentialsCommand);\n    context.subscriptions.push(selectTestSuiteCommand);\n    context.subscriptions.push(exportMappingCommand);\n    context.subscriptions.push(importMappingCommand);\n    context.subscriptions.push(rebuildAllMappingsCommand);\n    context.subscriptions.push(applyTestsCommand);\n    context.subscriptions.push(publishAppAndTestappCommand);\n    context.subscriptions.push(publishTestappCommand);\n\n    // Register the Selective Tests View\n    const selectiveTestsProvider = new SelectiveTestsProvider(context);\n    vscode.window.registerTreeDataProvider('selectiveTestsView', selectiveTestsProvider);\n    vscode.commands.registerCommand('bc-testrunner.refreshSelectiveTests', () => selectiveTestsProvider.refresh());\n\n    // Register the All Tests View\n    const allTestsProvider = new AllTestsProvider(context);\n    vscode.window.registerTreeDataProvider('allTestsView', allTestsProvider);\n    vscode.commands.registerCommand('bc-testrunner.refreshAllTests', () => allTestsProvider.refresh());\n\n    // Hook into the Git Commit process\n    const gitExtension = vscode.extensions.getExtension('vscode.git');\n    if (gitExtension) {\n        // const git = gitExtension.exports;\n        // const api = git.getAPI(1);\n\n        // api.onDidChangeState(async (state: any) => {\n        //     if (state === 'commit') {\n        //         const testSuite = await selectOrCreateTestSuite(context);\n        //         runTests(context, testSuite);\n        //     }\n        // });\n    } else {\n        vscode.window.showErrorMessage(\"Git extension is not available.\");\n    }\n\n    console.info(\"Business Central AL Test Runner: Activation completed\");\n}\n\nexport function deactivate() {}"
    },
    {
        "role": "assistant",
        "content": "Datei gespeichert und verstanden. Bitte fortfahren"
    },
    {
        "role": "user",
        "content": "test"
    }
]